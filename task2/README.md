## Task2: Microsoft SEAL Code 분석
### 5_ckks_basics.cpp, 6_rotation.cpp 코드 분석

### 주어진 다항식: $PIx^3 + 0.4x + 1$

-----------
CKKS에서는 곱셈이 암호문의 스케일을 증가시킴.<br>
암호문의 스케일이 계수 모듈러스(codeff_modulus)의 전체 크기와 너무 가까워지면 스케일업된 평문을 저장하기에 충분한 공간이 부족해지는 문제 발생.

    -> 이를 해결하기 위해 rescale 기능을 제공하는데, 이를 통해 스케일을 줄이고 스케일의 증가를 안정화할 수 있음.
스케일링은 모듈러스 스위칭(modulus switching)의 한 형태로 작동.

### 모듈러스 스위칭? 

암호화 매개변수(coeff_modulus)를 변경하는 연산. 계수 모듈러스의 마지막 소수를 제거하고 암호문을 스케일 다운.<br>
모듈러스 스위칭은 일반적으로 다음과 같은 두 가지 상황에서 사용:

1. **스케일(scale) 변경**: 암호문의 스케일을 조절
    
   CKKS 스키마에서 스케일은 암호화된 부동 소수점 수의 정밀도를 나타내는 지표<br>
   스케일이 클수록 정밀도가 낮아지고, 스케일이 작을수록 정밀도가 높아짐<br>
   모듈러스 스위칭을 통해 스케일을 조절하여 계산의 정확도와 성능 사이에서 적절한 균형을 유지
    
3. **암호문의 크기 조절**: 암호문의 크기가 너무 커서 처리하기 어려운 경우, 모듈러스 스위칭을 통해 암호문의 크기를 줄임
    
   이는 암호문의 계수 체인에서 레벨을 낮추는 과정.<br>
   레벨이 낮아질수록 암호문의 크기가 작아지지만, 그에 따라 계산의 정확도가 낮아질 수 있음. -> 따라서 적절한 레벨과 스케일 조정이 필요.
   
-----------

CKKS 암호문의 스케일이 S이고, 현재 계수 모듈러스의 마지막 소수가 P라고 가정하자.<br>
다음 레벨로 rescaling하면 스케일은 S/P이 되고, 계수 모듈러스의 소수 P를 제거.<br>
소수의 개수는 rescaling을 할 수 있는 횟수를 제한하여 연산의 곱셈적 깊이를 제한.<br>

초기 스케일을 자유롭게 선택할 수 있음.<br>

    좋은 전략: 초기 스케일 S와 계수 모듈러스의 소수 P_i를 서로 매우 가깝게 설정

-> 만약 곱셈 전에 암호문의 스케일이 S이고, 곱셈 후에는 S^2가 되고, 스케일링 후에는 S^2/P_i가 되는 경우를 생각해보자.<br>
만약 모든 P_i가 S에 가깝다면, S^2/P_i는 다시 S에 가까워짐.<br>
-> 이렇게 하면 계산 중에 스케일을 S에 가깝게 안정화시킬 수 있음
		
일반적으로 깊이 D의 회로에는 D번의 스케일링이 필요 = 계수 모듈러스에서 D개의 소수를 제거할 수 있어야 함<br>
계수 모듈러스에 하나의 소수만 남게 되면, 남은 소수는 S보다 약간 더 큰 값이어야 함(평문의 소수 자릿수를 유지하기 위해)
		
    일반적인 CKKS 스키마에 대한 매개 변수 선택 전략:
1) 계수 모듈러스의 첫 번째 소수로 60비트 소수를 선택. 이는 복호화 시, 가장 높은 정밀도를 제공하기 위함.
2) 계수 모듈러스의 마지막 소수로 또 다른 60비트 소수를 선택. 이는 특수한 소수로 사용되며 다른 소수 중 가장 커야 함.
3) 중간 소수들은 서로 가깝게 선택

-----------

라이브러리를 설치하고, 주어진 주석을 통해 분석하였음
